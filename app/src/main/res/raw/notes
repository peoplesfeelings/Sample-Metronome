to do
    consider how to bake in error correction
        in the track
    find out if there is a minimum length feasible without letting buffered pcm run out
    switch to an actual loop instead of a handler looper
    switch to streaming pcm to audiotrack
    switch to BigDecimal for interval and values used to produce interval
        MILLIS_IN_MINUTE
        fta
        SENSITIVITY_FACTOR
        rate
        count
    establish tests for timing precision
        getTimingDeviationForTick
        getPossibleTimingDeviationFromStart
    add size limit for sample
    redo error reporting from service so that it can be sent to either activity
    fix activity starting triggering stop()
    remove thing.wav and wood_beam.wav
    fix margins on about page
    if more than 1 tick per beat, sub-beats should be lower volume
    if (mime.startsWith("audio/"))
    i think i remember fixing an issue by changing a factor of 2 to 1 or 1 to 2
        i think i was erroneously writing to byte array when i should have been writing to short array
    look into error reporting
        android playstore
        log file
        popup with email link
    new features
        settings page - dial sensitivity

store listing
    precision
    connect by usb. put in sample_metronome folder
    update accepted files

maybe do
    consolidate similar code across format decoders/parsers
    move fileNeedsToBeLoaded to Dry
    call at.release in onstop?
        would need to set fileNeedsToBeLoaded to true
    replace WaveInfo with subclass of MediaFormat
    remove fileBeingLoaded initialization in service onCreate

audiotrack
    https://android.googlesource.com/platform/frameworks/base/+/android-4.4_r1/media/java/android/media/AudioTrack.java

precision testing
    https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html
    2 types of precision
        deviation from start
            measurement:
            metric: time until possibleDeviationFromStart > allowedDeviationFromStart
            tickTime = startTime + (interval * count)
                     = startTime:long + ( ( (MILLIS_IN_MINUTE:int / (fta:double * SENSITIVITY_FACTOR:double) ) / rate:double) * count)
                     = startTime:long + ( ( (int / (double * double) ) / double) * int)
                startTime: long
                    comes from upTimeMillis
                interval: double
                    comes from setInterval
                        ( MILLIS_IN_MINUTE / ftaToBPM ) / rate
                        MILLIS_IN_MINUTE: int: 60 000
                        ftaToBPM
                            fta * SENSITIVITY_FACTOR
                                fta: double
                                SENSITIVITY_FACTOR: double
                        rate: double
                count: int
            scale of interval a factor
        deviation for tick
            difference between millis when sample plays and millis when it should have played
            scale of interval a factor



documentation (technical design to be replaced by pending new rebuild)
    had to go with AudioTrack class because MediaPlayer and SoundPool introduce latency to timing of individual ticks being played
        alternatives like exoplayer are bloated. using them to get raw PCM is as much as work as just decoding files ourselves
        decoding the audio files in order to feed AudioTrack raw PCM data means using the MediaCodec API
            MediaCodec works best with the getInputBuffer/getOutputBuffer calls introduced in API 21, so that's the min API level
        because we're decoding audio files ourselves we have to be careful about validating the files
            so we need to be able to alert the user if a file is not usable for some reason
            because it's desirable to allow user to change audio file selection while metronome is playing, loadFile() can be initiated by user from main activity screen or sample screen
                rather than feeding potential error message to either activity, we just bring main activity to top of stack and show user error dialog there
                    main activity establishes connection to service in activity onstart using async serviceconnection callback so sometimes we have to stash the error message in the service for a moment then have main activity check if there is an error message stashed
    main activity
        onStart
            checks if service is running, and if not, starts it
            establishes connection to service
                once connected
                    activity checks service's playing bool to set button text accordingly
                    dial is set up here because onmove and onup listeners call service's setinterval
                    edittext is set up here because the textwatcher's aftertextchanged listener calls service's setinterval
                    spinner is set up here because the spinner's setonitemclicklistener assigns the service's rate member and calls setinterval
                        also the setUpSpinner() method assigns the rate member the value loaded from shareprefs
                    setUpListeners() called here because start/stop button calls service methods start(), stop(), and setinterval()
                    activity gives service reference to activity instance so service can show problem dialog if needed
        onStop
            assigns null to service's reference to activity
            unbinds
        versionSetUp
            called in onRequestPermissionsResult() and getPermissionForWrite()
                because it's where we write samples so we need write permission
            the requirements that led to this are:
                developer can include new samples in new app version
                when user's app is updated, only new samples are written (deleted samples won't be written again)
                samples we don't like anymore can be removed and they won't be written to new installers
                    but will remain for people who have them already
    service
        audio player kept in service so screen can sleep and player wont be destroyed
        started when activity starts, if not started already
        stopped in activity's ondestroy, if bound and not playing
        foreground
            started in start(), stopped in stop()
        when service starts
            instantiates myBinder which provides getter for reference to service instance for use by main activity
        playing boolean
            only set in start(), stop(), and initialized in service onCreate
        looper
            comes from handlerthread
            posted to using a handler instance
            the runnable is the thing that's run on it
            the runnable posts itself to the looper using postAtTime() to queue up the next tick
        the runnable
            checks if file needs to be loaded and calls loadFile on main thread if needed
                so files can be changed while metronome is playing
            only plays audiotrack if fileNeedsToBeLoaded is false, in case file is being decoded and audiotrack is being initialized in main thread
        fileNeedsToBeLoaded
            initialized true in service oncreate
            assigned true when user selects a different sample in sample screen
            read only in looper runnable
            only set false after successful file load
        fileBeingLoaded
            assigned true at beginning of loadFile() and false at the end of loadFile()
            checked, along with fileNeedsToBeLoaded, in looper runnable to decide if it should call loadFile
            looper and loadFile() are on separate threads so, without this check, user loading file that's too large could cause loadFile() to be called multiple times
        timing
            done in setInterval() and in the looper runnable
                done using startTime, lastTick, count, and interval
            setInterval may be called while loop is running, in which case startTime is changed
                this allows user to adjust dial while metronome is playing
            each tick's timing is always calculated relative to the startTime, which is the last time the metronome was started or the interval was changed
                this approach, as opposed to a recurring timer, cleanly eliminates many possible sources of timing inaccuracy
        setinterval()
            called by
                start/stop button listener
                dial onUp and onMove listeners
                edittext listener
                spinner listener
            when setinterval() is called,
                the start time is changed, if playing, otherwise set to -1, to be set when loop is started
                bpm is set from fta value
                interval is set as beat duration divided by rate
        dial's "full texture angle" (fta) is central store of the bpm
        seleted file name
            never set as empty
            initialized on install
            check for file.exists() done in start/stop button handler
    decoder workflow diagram
        https://drive.google.com/file/d/15RkGM2yxLSBOSa7fqDMVjZ_NewCASOQn/view?usp=sharing

performance optimizations
    quickest way to generate a chunk of silence




algorithm for new app technical design
    activities extends pfseqactivity
    service extends pfseq
        set up track and loop in setUpTracks
    PFSeq (reusable precision timing module for sequencers)
        threads
            PFSeq runs a "control loop" thread for the main real-time event processing
                expensive tasks needed from there should be run on the main thread, possibly queued
        PFSeqActivity abstract class
            purposes
                offer methods for service to use
                get binder, which has methods offered by service
            create a new ServiceConnection
                sets eventHandler for connection established that gets binder
            member variables
                bound
                serviceconnection
            abstract method
                showProblemInfo(String message)
                onConnect()
                    to be called in serviceconnection's onServiceConnected listener
                    an activity extending the abstract class may set up GUI event listeners that call service methods here
            method
                doBindService
                    if service not running, start service
                    if service not bound, bind service
                    bound = true
                doUnbindService
                    if bound
                        null callback
                        unbind
                        bound = false
                onStart
                    doBindService
                onStop
                    doUnbindService
        PFSeq abstract service
            inner class child class of Binder
                way for service to offer methods for activities to use
                    just give reference to the whole service instance
            life cycle
                created when a PFSeqActivity is created
                not explicitly destroyed. GC takes care of it if it is not foreground (if its no playing)
            constants
                extraTimeForProcessing1
                    how much latency should be catered for when calculating when to stream audiotrack a segment
                        how soon before the end of buffered pcm you need to send it more
            abstract methods
                setUpForeground
                setUpTracks
            member variables
                currentSampleRate
                ArrayList of Track objects
                tempoBeginsTime
                playingBeginsTime
                framesSent // since playing begins
                placeInTime                                                     [NOT USED HERE]
                mediaFormat
                bPM
                beatDuration
                    like 'interval' in previous design
                count // number of bars so far
                lastBeat // used when changing tempo
                baseActivity // connection to activity
            methods
                setCallbacks(PFSeqActivity)
                    when the activity receives the binder from the service, it gives the service a reference to itself
                onBind
                    return binder
                onUnbind
                    void pFSeqActivity
                setTempo
                    if playing
                        tempoBeginsTime = lastBeat
                        count = 0
                    else
                        startTime = -1
                    assign bpm
                    beatDuration = a minute / bpm
                setTimeSignature(TimeSignature)                                 [NOT USED HERE]
                getTimeSignature()                                              [NOT USED HERE]
                startPlaying()
                    toggle boolean
                    startforeground
                    create controlLoop thread
                stopPlaying()
                    toggle boolean
                    stopforeground
                handleProblem(message)
                    call baseActivity.showProblemInfo(message)
                getIsPlaying()
        PFSeqTrack class
            constant
                MAX_CLIP_LENGTH
            constructor(sequencer)
            private member variables
                loop
                audioTrack
                label                                                                [NOT USED HERE]
                clips
            public methods
                initializeAudioTrack(mediaFormat)
                getTrackLabel                                                        [NOT USED HERE]
                setTrackLabel                                                        [NOT USED HERE]
                setClip(clipLabel, filename)
                removeClip(clipLabel)
                play(placeInTime)
                    creat thread
                    run on thread
                stop()
            member boolean
                readyToPlay
        PFSeqTimeSignature class
            beatsPerBar
            NoteValueForBeat
        PFSeqNoteValue class
            enum class with constructor to set BigDecimal value
        PFSeqClip class
            constant
                MAX_CLIP_LENGTH
            constructor(track)
            member variables
                fileBeingLoaded
                fileNeedsToBeLoaded
                    initialized true
                label
                filename
                mediaFormat
                pCM
                track
            methods
                getPCM
                    if (fileNeedsToBeLoaded && not fileBeingLoaded)
                        loadFile (run on ui thread)
                    if (not fileNeedsToBeLoaded)
                loadFile(filename)
                    assign fileBeingLoaded true
                    compare file MediaFormat to track's audiotrack mediaFormat (and if it's null, the sequencer's mediaFormat)
                    if compatible
                        get the PCM and the MediaFormat
                        if clipLength over MAX_CLIP_LENGTH
                            abridge to MAX_CLIP_LENGTH
                        store length
                    else
                        set fileNeedsToBeLoaded to true and filename to empty string
                    assign fileNeedsToBeLoaded false
                    assign fileBeingLoaded false
                setLabel
                getLabel
                setFileNeedsToBeLoaded(filename)
                    clear PCM
                    assign filename
                    assign fileNeedsToBeLoaded true
                    assign fileBeingLoaded false
        PFSeqPianoRoll class
            beatsPerBar
                0 for non-repeating
            loopItems
        PFSeqPianoRollItem class
            position
                in beats
            clip
            velocity











########################## misc notes #########################################

48,000 samples per second means 48 samples per millisecond




########################## snippets i may never need ##########################

        Log.d(Dry.TAG, "THREAD: " + android.os.Process.getThreadPriority(android.os.Process.myTid()));


        if (format.containsKey(MediaFormat.KEY_MAX_INPUT_SIZE)) {
            inputBuffer = ByteBuffer.allocate(format.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE));
        } else {
            inputBuffer = ByteBuffer.allocate((int) new File(fileLocation).length());
        }
        while (extractor.readSampleData(inputBuffer, 0) >= 0) {
            extractor.advance();
        }

