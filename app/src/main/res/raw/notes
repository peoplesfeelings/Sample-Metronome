to do
    fix activity starting triggering stop()

store listing
    precision
    connect by usb. put in sample_metronome folder
    update accepted files

maybe do
    move fileNeedsToBeLoaded to Dry
    call at.release in onstop?
        would need to set fileNeedsToBeLoaded to true
    replace WaveInfo with subclass of MediaFormat
    consolidate similar code across format decoders/parsers
    remove fileBeingLoaded initialization in service onCreate

audiotrack
    https://android.googlesource.com/platform/frameworks/base/+/android-4.4_r1/media/java/android/media/AudioTrack.java



documentation
    had to go with AudioTrack class because MediaPlayer and SoundPool introduce latency to timing of individual ticks being played
        alternatives like exoplayer are bloated. using them to get raw PCM is as much as work as just decoding files ourselves
        decoding the audio files in order to feed AudioTrack raw PCM data means using the MediaCodec API
            MediaCodec works best with the getInputBuffer/getOutputBuffer calls introduced in API 21, so that's the min API level
        because we're decoding audio files ourselves we have to be careful about validating the files
            so we need to be able to alert the user if a file is not usable for some reason
            because it's desirable to allow user to change audio file selection while metronome is playing, loadFile() can be initiated by user from main activity screen or sample screen
                rather than feeding potential error message to either activity, we just bring main activity to top of stack and show user error dialog there
                    main activity establishes connection to service in activity onstart using async serviceconnection callback so sometimes we have to stash the error message in the service for a moment then have main activity check if there is an error message stashed
    main activity
        onStart
            checks if service is running, and if not, starts it
            establishes connection to service
                once connected
                    activity checks service's playing bool to set button text accordingly
                    dial is set up here because onmove and onup listeners call service's setinterval
                    edittext is set up here because the textwatcher's aftertextchanged listener calls service's setinterval
                    spinner is set up here because the spinner's setonitemclicklistener assigns the service's rate member and calls setinterval
                        also the setUpSpinner() method assigns the rate member the value loaded from shareprefs
                    setUpListeners() called here because start/stop button calls service methods start(), stop(), and setinterval()
                    activity gives service reference to activity instance so service can show problem dialog if needed
        onStop
            assigns null to service's reference to activity
            unbinds
    service
        audio player kept in service so screen can sleep and player wont be destroyed
        started when activity starts, if not started already
        stopped in activity's ondestroy, if bound and not playing
        foreground
            started in start(), stopped in stop()
        when service starts
            instantiates myBinder which provides getter for reference to service instance for use by main activity
        playing boolean
            only set in start(), stop(), and initialized in service onCreate
        looper
            comes from handlerthread
            posted to using a handler instance
            the runnable is the thing that's run on it
            the runnable posts itself to the looper using postAtTime() to queue up the next tick
        the runnable
            checks if file needs to be loaded and calls loadFile on main thread if needed
                so files can be changed while metronome is playing
            only plays audiotrack if fileNeedsToBeLoaded is false, in case file is being decoded and audiotrack is being initialized in main thread
        fileNeedsToBeLoaded
            initialized true in service oncreate
            assigned true when user selects a different sample in sample screen
            read only in looper runnable
            only set false after successful file load
        fileBeingLoaded
            assigned true at beginning of loadFile() and false at the end of loadFile()
            checked, along with fileNeedsToBeLoaded, in looper runnable to decide if it should call loadFile
            looper and loadFile() are on separate threads so, without this check, user loading file that's too large could cause loadFile() to be called multiple times
        timing
            done in setInterval() and in the looper runnable
                done using startTime, lastTick, count, and interval
            setInterval may be called while loop is running, in which case startTime is changed
                this allows user to adjust dial while metronome is playing
            each tick's timing is always calculated relative to the startTime, which is the last time the metronome was started or the interval was changed
                this approach, as opposed to a recurring timer, cleanly eliminates many possible sources of timing inaccuracy
        setinterval()
            called by
                start/stop button listener
                dial onUp and onMove listeners
                edittext listener
                spinner listener
            when setinterval() is called,
                the start time is changed, if playing, otherwise set to -1, to be set when loop is started
                bpm is set from fta value
                interval is set as beat duration divided by rate
        dial's "full texture angle" (fta) is central store of the bpm
        seleted file name
            never set as empty
            initialized on install
            check for file.exists() done in start/stop button handler
    decoder workflow diagram
        https://drive.google.com/file/d/15RkGM2yxLSBOSa7fqDMVjZ_NewCASOQn/view?usp=sharing













########################## snippets i may never need ##########################

        Log.d(Dry.TAG, "THREAD: " + android.os.Process.getThreadPriority(android.os.Process.myTid()));


        if (format.containsKey(MediaFormat.KEY_MAX_INPUT_SIZE)) {
            inputBuffer = ByteBuffer.allocate(format.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE));
        } else {
            inputBuffer = ByteBuffer.allocate((int) new File(fileLocation).length());
        }
        while (extractor.readSampleData(inputBuffer, 0) >= 0) {
            extractor.advance();
        }

